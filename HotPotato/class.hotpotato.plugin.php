<?php

/**
 * @copyright 2003 Vanilla Forums, Inc
 * @license Proprietary
 */
$PluginInfo['HotPotato'] = array(
    'Name' => 'Minion: HotPotato',
    'Description' => "HotPotato game and badges.",
    'Version' => '1.0a',
    'RequiredApplications' => array(
        'Vanilla' => '2.1a',
        'Reputation' => '1.0'
    ),
    'RequiredPlugins' => array(
        'Minion' => '1.12',
        'Reactions' => '1.2.1'
    ),
    'MobileFriendly' => TRUE,
    'Author' => "Tim Gunter",
    'AuthorEmail' => 'tim@vanillaforums.com',
    'AuthorUrl' => 'http://vanillaforums.com'
);

/**
 * HotPotato Plugin
 *
 * This plugin uses Minion, Reactions, and Badges to create a forum game that
 * resembles Hot Potato.
 *
 * Changes:
 *  1.0     Release
 *
 * @author Tim Gunter <tim@vanillaforums.com>
 * @package misc
 */
class HotPotatoPlugin extends Gdn_Plugin {

    const POTATO_KEY = 'minion.hotpotato.potato.%s';

    /**
     * List of known potatoes
     * @var array
     */
    protected $potatoes;

    /**
     * Startup configuration
     *
     */
    public function __construct() {
        parent::__construct();

        $this->potatoes = [];
    }

    /**
     * Hook for E:Token from MinionPlugin
     *
     * Parse a token from the current state while running checkCommands. This
     * method allows us to intercept Minion invocations and attach custom
     * functionality.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Token_Handler($sender) {
        $state = &$sender->EventArguments['State'];

        // Start hot potato
        if (!$state['Method'] && in_array($state['CompareToken'], array('toss'))) {
            $sender->consume($state, 'Method', 'hotpotato');
        }

        // Get potato name
        if ($state['Method'] == 'hotpotato') {
            if (in_array($state['CompareToken'], array('a'))) {
                $sender->consume($state, 'Gather', array(
                    'Node' => 'Potato',
                    'Type' => 'phrase',
                    'Delta' => '',
                    'Terminator' => true,
                    'Boundary' => ['to', 'at']
                ));
            }
        }
    }

    /**
     * Hook for E:Command from MinionPlugin
     *
     * Parse custom minion commands. This method adds action handling for the
     * commands matched during token parsing and queueing associates command
     * execution.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Command_Handler($sender) {
        $actions = &$sender->EventArguments['Actions'];
        $state = &$sender->EventArguments['State'];

        // If we don't know the targetted user, try to detect by a quote
        if (!key_exists('User', $state['Targets'])) {
            $sender->matchQuoted($state);
        }

        switch ($state['Method']) {
            case 'hotpotato':
                $actions[] = array('hotpotato', null, $state);
                break;
        }
    }

    /**
     * Hook for E:Action from MinionPlugin
     *
     * Perform custom minion actions. This method handles the queued actions generated by matching commands from user
     * input.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Action_Handler($sender) {
        $action = $sender->EventArguments['Action'];
        $state = $sender->EventArguments['State'];

        switch ($action) {

            case 'hotpotato':

                if (!key_exists('User', $state['Targets'])) {
                    $sender->acknowledge(null, T('You must supply a valid target user.'), 'custom', $state['Sources']['User'], [
                        'Comment' => false
                    ]);
                    break;
                }

                // Target already has a potato?
                $tossToUser = &$state['Targets']['User'];
                $targetHasPotato = $sender->monitoring($tossToUser, 'hotpotato', false);
                if ($targetHasPotato) {
                    $targetPotatoHash = val('hash', $targetHasPotato, null);
                    $targetPotato = $this->getPotato($targetPotatoHash);
                    $sender->acknowledge(null, T("{Target.Name} is already holding a {Potato.name}!"), 'custom', $state['Sources']['User'], [
                        'Comment' => false
                    ], [
                        'Target' => $tossToUser,
                        'Potato' => $targetPotato
                    ]);
                    break;
                }

                $potato = false;

                // Check access control

                // Someone who has a potato may toss it
                $haveHotPotato = $sender->monitoring(Gdn::session()->User, 'hotpotato', false);
                if ($haveHotPotato) {
                    $potatoHash = val('hash', $haveHotPotato, null);
                    $potato = $this->getPotato($potatoHash);

                    // Check this potato!
                    if ($potato) {
                        $potatoName = $potato['name'];
                        $potatoOk = $this->checkPotato($potato);
                        if (!$potatoOk) {
                            $sender->acknowledge(null, T('The {Potato.name} slips from your hand as you toss it!'), 'custom', $state['Sources']['User'], [
                                'Comment' => false
                            ],[
                                'Potato' => $potato
                            ]);
                            break;
                        }
                    }
                }

                // Moderators may create new potatos

                if (!$potato && Gdn::session()->checkPermission('Garden.Moderation.Manage')) {
                    $newPotatoName = valr('Targets.Potato', $state, null);
                    if (!$newPotatoName) {
                        $sender->acknowledge(null, T('You must supply a name for the thing you want to toss!'), 'custom', $state['Sources']['User'], [
                            'Comment' => false
                        ]);
                        break;
                    }

                    // Got a potato name, try to create
                    $duration = val('Time', $state, null);
                    if (!is_null($duration)) {
                        $duration = $duration - time();
                        if ($duration <= 0) {
                            $duration = null;
                        }
                    }
                    if (!is_integer($duration)) {
                        $duration = strtotime('+'.C('Plugins.HotPotato.Duration', '10 days'));
                        $duration = $duration - time();
                    }

                    if (!is_integer($duration)) {
                        $duration = 84600;
                    }
                    $potato = $this->newPotato($newPotatoName, $duration, Gdn::session()->UserID);
                }

                // No potato, or failed to create potato
                if (!$potato) {
                    $sender->acknowledge(null, T("Couldn't find anything to toss!"), 'custom', $state['Sources']['User'], [
                        'Comment' => false
                    ]);
                    break;
                }

                // Toss potato
                $this->toss($potato, $tossToUser, Gdn::session()->User);
                break;
        }
    }

    /**
     * Create a new potato
     *
     * @param string $name
     * @param integer $duration
     * @param integer $userID
     * @return string potato id hash
     */
    public function newPotato($name, $duration, $userID) {

        $potatoHash = md5($name);

        // Check if potato already exists and is active
        $potato = $this->getPotato($potatoHash, true);
        if (is_array($potato) && $potato['status'] == 'active') {
            return false;
        }

        $potatoKey = sprintf(self::POTATO_KEY, $potatoHash);
        $expiry = time() + $duration;
        $hold = strtotime('+'.C('Plugins.HotPotato.Hold', '8 hours')) - time();
        $potato = [
            'name' => $name,
            'hash' => $potatoHash,
            'duration' => $duration,
            'hold' => $hold,
            'status' => 'active',
            'expiry' => $expiry,
            'passes' => 0,
            'misses' => 0,
            'owner' => $userID
        ];
        Gdn::set($potatoKey, json_encode($potato));

        $this->potatoes[$potatoHash] = $potato;

        return $potato;
    }

    /**
     * Get a potato
     *
     * @param string $potatoHash
     * @param boolean $hardCheck force database/memcache check
     */
    public function getPotato($potatoHash, $hardCheck = false) {
        $potato = null;

        if (!$hardCheck) {
            $potato = val($potatoHash, $this->potatoes, null);

            // Known non potato
            if ($potato === false) {
                return false;
            }
        }

        // Unknown, query
        if (!$potato) {
            $potatoKey = sprintf(self::POTATO_KEY, $potatoHash);
            $potato = Gdn::get($potatoKey, false);
            if ($potato) {
                $potato = json_decode($potato, true);
            }

            $this->potatoes[$potatoHash] = $potato;
        }
        return $potato;
    }

    /**
     * Save a modified potato
     *
     * @param array $potato
     * @return array the modified potato
     */
    public function savePotato($potato) {
        $potatoHash = $potato['hash'];
        $potatoKey = sprintf(self::POTATO_KEY, $potatoHash);
        Gdn::set($potatoKey, json_encode($potato));
        $this->potatoes[$potatoHash] = $potato;

        return $potato;
    }

    /**
     * Process a toss from someone to someone
     *
     * @param MinionPlugin $minion
     * @param array $potato
     * @param array $to
     * @param array $from
     * @param boolean $voluntary optional. whether this was a voluntary toss, or a drop
     */
    public function toss($minion, $potato, $to, $from, $voluntary = true) {

        // Remove from tosser (hah)
        $minion->monitor($from, [
            'hotpotato' => null
        ]);

        // Give to recipient
        $minion->monitor($to, [
            'hotpotato' => [
                'hash' => $potato['hash'],
                'received' => time(),
                'expires' => time() + $potato['hold']
            ]
        ]);

        // Increment potato toss counter
        if ($voluntary) {
            $potato['passes']++;
        } else {
            $potato['misses']++;
        }
        $this->savePotato($potato);

        // Log potato transaction

    }

    /**
     * 
     */
    public function setup() {

    }

    /**
     * Run database structure modifications
     *
     * This is executed once when the plugin is enabled, and also whenever /utility/update is called.
     */
    public function structure() {

    }

}
